import time
import streamlit as st
from streamlit_folium import folium_static
import pandas as pd
from datetime import datetime, timedelta
import pytz
import os
import time
from functools import lru_cache
import requests
import geopandas as gpd
from datetime import datetime
import pandas as pd
import numpy as np
import streamlit as st
import plotly.express as px
import folium
from io import BytesIO
import pytz
from shapely.geometry import Point, mapping
import pyarrow.parquet as pq
from shapely import wkb
import json
from shapely.errors import GEOSException

@st.cache_data(ttl=300)  # Increased TTL to 5 min
def load_data(selected_day):
    tz = pytz.timezone('America/New_York')
    formatted_day = selected_day.replace(' ', '+')
    current_date = datetime.now(tz).strftime("%Y%m%d")
    
    cloudfront_url = os.environ.get('CLOUDFRONT_URL', 'https://heat-risk-dashboard.s3.amazonaws.com')
    url = f'{cloudfront_url}/heat_risk_analysis_{formatted_day}_{current_date}.geoparquet'

    start_time = time.time()

    try:
        with requests.get(url, stream=True) as response:
            response.raise_for_status()
            data = BytesIO(response.content)
        
        # Use pyarrow to read the Parquet file more efficiently
        table = pq.read_table(data)
        df = table.to_pandas()

        # Convert the geometry column from WKB to shapely geometries
        df['geometry'] = df['geometry'].apply(lambda x: wkb.loads(x) if x else None)

        # Create GeoDataFrame and set the geometry column
        gdf = gpd.GeoDataFrame(df, geometry='geometry', crs="EPSG:4326")

        return gdf

    except Exception as e:
        st.error(f"An error occurred while loading the data: {e}")
        return None

    except requests.exceptions.RequestException as e:
        end_time = time.time()
        download_time = end_time - start_time

        st.error(f'{current_date},{url}')
        st.error(f"Failed to download data: {e}")
        print(f"Download failed after {download_time:.2f} seconds")
        return None
    
    except Exception as e:
        end_time = time.time()
        download_time = end_time - start_time

        st.error(f"An error occurred while loading the data: {e}")
        print(f"Data loading failed after {download_time:.2f} seconds")
        return None

@lru_cache(maxsize=None)
def load_state_county_zip_data():
    states_file = "data/us_states_reduced.parquet"
    counties_file = "data/us_counties_reduced.parquet"
    zipcodes_file = "data/us_zipcodes_reduced.parquet"

    states = gpd.read_parquet(states_file)
    counties = gpd.read_parquet(counties_file)
    zipcodes = gpd.read_parquet(zipcodes_file)

    for gdf in [states, counties, zipcodes]:
        if not gdf.crs.is_geographic:
            gdf.to_crs(epsg=4326, inplace=True)

    return states, counties, zipcodes

@lru_cache(maxsize=1000)
def get_zipcode_boundary(zip_code):
    _, _, zipcodes = load_state_county_zip_data()
    column_name = 'ZCTA5CE10'
    return zipcodes[zipcodes[column_name] == str(zip_code)]

def load_geographic_data():
    states, counties, _ = load_state_county_zip_data()

    state_names = ["Select a State"] + sorted(states['NAME'].unique())
    selected_state = st.sidebar.selectbox("Select State", state_names)

    if selected_state != "Select a State":
        filtered_counties = counties[counties['STATE_NAME'] == selected_state]
        county_names = ["Select a County"] + sorted(filtered_counties['NAME'].unique())
    else:
        county_names = ["Select a County"]

    selected_county = st.sidebar.selectbox("Select County", county_names)

    zip_code = st.sidebar.text_input("Enter ZIP Code to Zoom In", placeholder="e.g., 10044")
    zipcode_boundary = get_zipcode_boundary(zip_code) if zip_code else None

    return states, counties, selected_state, selected_county, zipcode_boundary

def generate_column_mapping(columns, prefix='weighted_', replacement='weighted ', title_case=True):
    if title_case:
        return {col: col.replace(prefix, replacement).replace('_', ' ').title() for col in columns if col.startswith(prefix)}
    else:
        return {col: col.replace(prefix, replacement).replace('_', ' ') for col in columns if col.startswith(prefix)}

def move_column_to_front(columns, column_name):
    if column_name in columns:
        return [column_name] + [col for col in columns if col != column_name]
    return columns

@lru_cache(maxsize=None)
def load_hhi_description(file_path='data/HHI_Data_Dictionary_2024.csv'):
    return pd.read_csv(file_path)

def get_hhi_indicator_description(hhi_desc_df, indicator_name):
    try:
        return hhi_desc_df.loc[hhi_desc_df['weighted_2024_VARIABLE_NAME'] == indicator_name, '2024_DESCRIPTION'].values[0]
    except IndexError:
        return "No description available for this indicator."

def get_heat_risk_levels_description():
    return """
    **Heat Risk Levels:**
    
    - **0:** Little to no risk from expected heat.
    - **1:** Minor - This level of heat affects primarily those individuals extremely sensitive to heat, especially when outdoors without effective cooling and/or adequate hydration.
    - **2:** Moderate - This level of heat affects most individuals sensitive to heat, especially those without effective cooling and/or adequate hydration. Impacts possible in some health systems and in heat-sensitive industries.
    - **3:** Major - This level of heat affects anyone without effective cooling and/or adequate hydration. Impacts likely in some health systems, heat-sensitive industries, and infrastructure.
    - **4:** Extreme - This level of rare and/or long-duration extreme heat with little to no overnight relief affects anyone without effective cooling and/or adequate hydration. Impacts likely in most health systems, heat-sensitive industries, and infrastructure.
    """

@lru_cache(maxsize=None)
def project_single_geometry(geom, from_crs, to_crs):
    return gpd.GeoSeries([geom], crs=from_crs).to_crs(to_crs)[0]

def project_geometries(geometries, from_crs, to_crs):
    if isinstance(geometries, (list, tuple)):
        return [project_single_geometry(geom, from_crs, to_crs) for geom in geometries]
    else:
        return project_single_geometry(geometries, from_crs, to_crs)

def create_map(layer1_with_weighted_values, selected_hhi_indicator, heat_threshold, heat_health_index_threshold, selected_state, selected_county, states, counties, zipcode_boundary=None):
    if layer1_with_weighted_values.empty:
        st.warning("The data is empty. Please check your inputs.")
        return None

    percentile_threshold = np.percentile(layer1_with_weighted_values[selected_hhi_indicator], heat_health_index_threshold)

    highlighted_areas = layer1_with_weighted_values.copy()
    # Use vectorized operations instead of apply where possible
    highlighted_areas['highlight'] = (
        (highlighted_areas[selected_hhi_indicator] >= percentile_threshold) & 
        (highlighted_areas['raster_value'].isin(heat_threshold))
    )

    # Project all geometries to EPSG:5070 once
    highlighted_areas_projected = highlighted_areas.to_crs(epsg=5070)
    states_projected = states.to_crs(epsg=5070)
    counties_projected = counties.to_crs(epsg=5070)

    # Simplify geometries with error handling
    tolerance = 1000  # Adjust this value to balance between speed and accuracy
    
    def safe_simplify(geometry):
        try:
            return geometry.simplify(tolerance)
        except GEOSException:
            return geometry

    # Use vectorized operations for simplification
    highlighted_areas_projected['geometry'] = highlighted_areas_projected.geometry.apply(safe_simplify)
    states_projected['geometry'] = states_projected.geometry.apply(safe_simplify)
    counties_projected['geometry'] = counties_projected.geometry.apply(safe_simplify)


    selected_state_geom = states_projected.loc[states_projected['NAME'] == selected_state, 'geometry'].values[0] if selected_state != "Select a State" else None
    selected_county_geom = counties_projected.loc[(counties_projected['STATE_NAME'] == selected_state) & (counties_projected['NAME'] == selected_county), 'geometry'].values[0] if selected_county != "Select a County" and selected_state_geom is not None else None

    initial_location = Point(highlighted_areas_projected.geometry.centroid.x.mean(), highlighted_areas_projected.geometry.centroid.y.mean())
    initial_zoom = 4

    if zipcode_boundary is not None:
        zipcode_boundary_projected = zipcode_boundary.to_crs(epsg=5070)
        zipcode_boundary_projected['geometry'] = zipcode_boundary_projected.geometry.apply(safe_simplify)
        initial_location = zipcode_boundary_projected.geometry.centroid.iloc[0]
        initial_zoom = 13
    elif selected_county_geom is not None:
        initial_location = selected_county_geom.centroid
        initial_zoom = 8
    elif selected_state_geom is not None:
        initial_location = selected_state_geom.centroid
        initial_zoom = 6

    # Project initial_location back to EPSG:4326 for Folium
    initial_location = project_geometries(initial_location, from_crs='EPSG:5070', to_crs='EPSG:4326')
    initial_location = [initial_location.y, initial_location.x]

    m = folium.Map(location=initial_location, zoom_start=initial_zoom)

    if selected_state_geom is not None:
        folium.GeoJson(json.dumps(mapping(project_geometries(selected_state_geom, from_crs='EPSG:5070', to_crs='EPSG:4326'))),
                       name="State Boundary", 
                       style_function=lambda x: {'color': 'green', 'weight': 2, 'fillOpacity': 0.1}).add_to(m)

    if selected_county_geom is not None:
        folium.GeoJson(json.dumps(mapping(project_geometries(selected_county_geom, from_crs='EPSG:5070', to_crs='EPSG:4326'))),
                       name="County Boundary", 
                       style_function=lambda x: {'color': 'yellow', 'weight': 2, 'fillOpacity': 0.7}).add_to(m)

    if zipcode_boundary is not None:
        folium.GeoJson(json.dumps(mapping(zipcode_boundary_projected.to_crs(epsg=4326).geometry.iloc[0])),
                       name="ZIP Code Boundary", 
                       style_function=lambda x: {'color': 'black', 'weight': 3, 'fillOpacity': 0.5}).add_to(m)

    folium.GeoJson(
        highlighted_areas_projected.to_crs(epsg=4326).__geo_interface__,
        style_function=lambda feature: {
            'fillColor': 'red' if feature['properties']['highlight'] else 'blue',
            'color': 'black',
            'weight': 0.1,
            'fillOpacity': 0.7 if feature['properties']['highlight'] else 0.3,
        },
        tooltip=folium.GeoJsonTooltip(
            fields=[selected_hhi_indicator, 'raster_value'],
            aliases=[selected_hhi_indicator.replace('weighted_', ''), 'Heat Risk Level:'],
            localize=True,
            sticky=True
        )
    ).add_to(m)

    legend_html = f'''
        <div style="position: fixed; bottom: 50px; left: 50px; width: 220px; height: 90px; 
                    border:2px solid grey; z-index:9999; font-size:14px;
                    background-color:white;
                    ">
        &nbsp; Legend <br>
        &nbsp; <i class="fa fa-square fa-1x"
                    style="color:red"></i> Highlighted Areas (Heat Risk {heat_threshold} & HHI {heat_health_index_threshold}th percentile)<br>
        &nbsp; <i class="fa fa-square fa-1x"
                    style="color:blue"></i> Other Areas
        </div>
        '''
    m.get_root().html.add_child(folium.Element(legend_html))

    return m

def create_plot(data, y_column, x_column, color_column, title, y_label, x_label, height=300, width=600):
    fig = px.bar(data, 
                 y=y_column, 
                 x=x_column, 
                 color=color_column,
                 labels={y_column: y_label, x_column: x_label},
                 title=title,
                 orientation='h',
                 height=height,
                 width=width)
    fig.update_layout(barmode='stack')
    return fig


# Set up the Streamlit app
st.set_page_config(layout="wide")

# Sidebar
st.sidebar.title("Heat Risk and Health Index Dashboard")
st.sidebar.markdown("This is an experimental prototype provided for informational purposes only by the [Jacobs Urban Tech Hub](https://urbantech.cornell.edu/) as part of the [Cornell Initiative on Aging and Adaptation to Extreme Heat](https://agingandadaptation.cornell.edu/).")

# Toggle for map size
map_size_option = st.sidebar.radio("Map Size", ("Regular", "Full Page"))

# Encourage the user to collapse the sidebar for full-page view
if map_size_option == "Full Page":
    st.sidebar.info("For a better view, you can hide the sidebar by clicking the arrow at the top-left corner.")

# Day selection
tz = pytz.timezone('America/New_York')
today = datetime.now(tz)

date_options = [(today + timedelta(days=i)).strftime("%m/%d/%Y") for i in range(7)]
day_options = [f"Day {i+1} - {date_options[i]}" for i in range(7)]

selected_day_label = st.sidebar.selectbox("Select Heat Risk Day", day_options)
selected_day = selected_day_label.split(' - ')[0]

# Filtering options
heat_threshold = st.sidebar.multiselect("Select Heat Risk Levels", [0, 1, 2, 3, 4], default=[2, 3, 4])

# Expander for learning more about heat risk levels
with st.sidebar.expander('Learn more about heat risk levels'):
    st.markdown(get_heat_risk_levels_description())

# Load the heat risk data
try:
    layer1_with_weighted_values = load_data(selected_day)
    if layer1_with_weighted_values is None or layer1_with_weighted_values.empty:
        st.error("Data could not be loaded. Please check the data source or network connection.")
except Exception as e:
    st.error(f"An error occurred while loading the data: {e}")
    layer1_with_weighted_values = None

# Check if data is loaded successfully
if layer1_with_weighted_values is None:
    st.error("Failed to load data. Please try again later.")
else:
    # Load geographic data using the utility function
    states, counties, selected_state, selected_county, zipcode_boundary = load_geographic_data()

# Generate the column mappings dynamically based on consistent formatting
hhi_column_mapping = generate_column_mapping(layer1_with_weighted_values.columns)

# Get the list of available columns for HHI indicators
hhi_columns = list(hhi_column_mapping.keys())
hhi_columns = move_column_to_front(hhi_columns, "weighted_OVERALL_SCORE")

# Create a list of display names
display_names = [hhi_column_mapping[col] for col in hhi_columns]

# Use the display names in the selectbox
selected_display_name = st.sidebar.selectbox(
    "Select CDC Heat and Health Index Indicator", 
    display_names,
    index=0
)

# Map the selected display name back to the actual column name
selected_hhi_indicator = hhi_columns[display_names.index(selected_display_name)]

# Load the HHI description data
hhi_desc_df = load_hhi_description()

# Get the description for the selected HHI indicator
description_text = get_hhi_indicator_description(hhi_desc_df, selected_hhi_indicator)

# Display the description in the expander
with st.sidebar.expander('Learn more about this HHI Indicator'):
    # make sure description text is on a new line
    st.markdown(f"""
        **{selected_hhi_indicator}**:

        {description_text}
        """)

heat_health_index_threshold = st.sidebar.slider("Heat Health Index Percentile Threshold", 0, 100, 80, step=10)

# Initialize filtered_data as an empty DataFrame
filtered_data = pd.DataFrame()

st.sidebar.write("Please click the button below to download the filtered data as a CSV file.")
st.sidebar.download_button(label="Download", data=filtered_data.to_csv(), mime='text/csv')

# Data source information
st.sidebar.markdown("""
**Data Sources:**
- [NWS Heat Risk](https://www.wpc.ncep.noaa.gov/heatrisk/)
- [CDC Heat and Health Index](https://ephtracking.cdc.gov/Applications/heatTracker/)
""")

# Main dashboard
start_time = time.time()
m = create_map(layer1_with_weighted_values, selected_hhi_indicator, heat_threshold, heat_health_index_threshold, selected_state, selected_county, states, counties, zipcode_boundary)
end_time = time.time()
map_creation_time = end_time - start_time

# Display success message with execution time
# st.success(f"Map created successfully in {map_creation_time:.2f} seconds")

# Adjust map size based on sidebar toggle
map_width, map_height = (1350, 900) if map_size_option == "Full Page" else (1000, 800)
folium_static(m, width=map_width, height=map_height)

st.markdown(f'''
<div style="position: relative; width: 400px; height: 150px; padding: 10px;">
    <b>Legend</b> <br>
    <span style="display: inline-block; width: 20px; height: 20px; background-color: red; margin-right: 10px;"></span> Highlighted Areas (Heat Risk {heat_threshold} & HHI {heat_health_index_threshold}th percentile)<br>
    <span style="display: inline-block; width: 20px; height: 20px; background-color: blue; margin-right: 10px;"></span> Other Areas
</div>
''', unsafe_allow_html=True)

if selected_state != "Select a State" or selected_county != "Select a County":
    if selected_county != "Select a County" and selected_state != "Select a State":
        selected_county_geom = counties[(counties['STATE_NAME'] == selected_state) & (counties['NAME'] == selected_county)].geometry.values
        if selected_county_geom.size > 0:
            filtered_data = layer1_with_weighted_values[layer1_with_weighted_values.intersects(selected_county_geom[0])]
            title_suffix = f" - {selected_state}, {selected_county}"
        else:
            st.warning("Could not find the geometry for the selected county.")
            filtered_data = pd.DataFrame()
    elif selected_state != "Select a State":
        selected_state_geom = states[states['NAME'] == selected_state].geometry.values
        if selected_state_geom.size > 0:
            filtered_data = layer1_with_weighted_values[layer1_with_weighted_values.intersects(selected_state_geom[0])]
            title_suffix = f" - {selected_state}"
        else:
            st.warning("Could not find the geometry for the selected state.")
            filtered_data = pd.DataFrame()
    else:
        filtered_data = layer1_with_weighted_values
        title_suffix = ""
    
    if not filtered_data.empty:
        st.subheader(f"Key Summary {title_suffix}")
        st.markdown("**Sociodemographic**")
        st.markdown(f"Affected population: {filtered_data['weighted_POP'].sum()}")

        with st.expander("See detailed plot for affected population"):
            # Prepare the data for the stacked bar chart
            population_by_risk_level = filtered_data.groupby('raster_value')['weighted_POP'].sum().reset_index()
            population_by_risk_level['raster_value'] = population_by_risk_level['raster_value'].astype(str)

            # Create the chart using the helper function
            fig_population = create_plot(population_by_risk_level, 
                                         y_column='raster_value', 
                                         x_column='weighted_POP', 
                                         color_column='raster_value',
                                         title="Population Affected by Heat Risk Level",
                                         y_label='Heat Risk Level', 
                                         x_label='Affected Population')
            st.plotly_chart(fig_population)

        st.markdown(f"Percentage of persons aged 65 and older estimate: {filtered_data['weighted_P_AGE65'].mean():.2f}%")

        with st.expander("See detailed plot for affected population aged 65 and older"):
            age65_by_risk_level = filtered_data.groupby('raster_value')['weighted_P_AGE65'].mean().reset_index()
            age65_by_risk_level['raster_value'] = age65_by_risk_level['raster_value'].astype(str)

            fig_age65 = create_plot(age65_by_risk_level,
                                    y_column='raster_value',
                                    x_column='weighted_P_AGE65',
                                    color_column='raster_value',
                                    title="Percentage of Persons Aged 65 and Older by Heat Risk Level",
                                    y_label='Heat Risk Level',
                                    x_label='Percentage of Persons Aged 65 and Older')
            st.plotly_chart(fig_age65)
    else:
        st.warning('No data available for the selected state or county.')
else:
    st.subheader('Select a State or County to get key summaries')

# Add the disclaimer to the footer
st.markdown("""
    <style>
    .footer {
        position: fixed;
        right: 0;
        bottom: 0;
        width: 30%;
        background-color: #f1f1f1;
        color: black;
        text-align: center;
        padding: 10px;
    }
    </style>
    <div class="footer">
        <br>Please fill out <a href="https://cornell.ca1.qualtrics.com/jfe/form/SV_4TTfOiGyOZJNVP0" target="_blank">our survey</a> to provide feedback. 
            <br>Bug reports to
        <a href="mailto:urbantech@cornell.edu">urbantech@cornell.edu</a>.

    </div>
""", unsafe_allow_html=True)