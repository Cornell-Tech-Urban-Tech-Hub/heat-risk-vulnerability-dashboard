import os
import time
from functools import lru_cache
import requests
import geopandas as gpd
from datetime import datetime
import pandas as pd
import numpy as np
import streamlit as st
import plotly.express as px
import folium
from io import BytesIO
import pytz
from shapely.geometry import Point, mapping
import pyarrow.parquet as pq
from shapely import wkb
import json
from shapely.errors import GEOSException
import pydeck as pdk
import os


@st.cache_data(ttl=300)  # Increased TTL to 5 min
def load_data(selected_day):
    tz = pytz.timezone('America/New_York')
    formatted_day = selected_day.replace(' ', '+')
    current_date = datetime.now(tz).strftime("%Y%m%d")
    
    cloudfront_url = os.environ.get('CLOUDFRONT_URL', 'https://heat-risk-dashboard.s3.amazonaws.com')
    url = f'{cloudfront_url}/heat_risk_analysis_{formatted_day}_{current_date}.geoparquet'

    start_time = time.time()

    try:
        print(f"Downloading {url}...")
        with requests.get(url, stream=True) as response:
            response.raise_for_status()
            data = BytesIO(response.content)
        
        # Use pyarrow to read the Parquet file
        table = pq.read_table(data)
        df = table.to_pandas()

        # Convert the geometry column from WKB to shapely geometries
        df['geometry'] = df['geometry'].apply(lambda x: wkb.loads(x) if x else None)

        # Create GeoDataFrame and set the geometry column
        gdf = gpd.GeoDataFrame(df, geometry='geometry', crs="EPSG:4326")

        end_time = time.time()
        download_time = end_time - start_time
        
        print(f"Download and processing completed in {download_time:.2f} seconds")
        # st.success(f"Data loaded successfully in {download_time:.2f} seconds")

        return gdf

    except requests.exceptions.RequestException as e:
        end_time = time.time()
        download_time = end_time - start_time

        st.error(f'{current_date},{url}')
        st.error(f"Failed to download data: {e}")
        print(f"Download failed after {download_time:.2f} seconds")
        return None
    
    except Exception as e:
        end_time = time.time()
        download_time = end_time - start_time

        st.error(f"An error occurred while loading the data: {e}")
        print(f"Data loading failed after {download_time:.2f} seconds")
        return None

@lru_cache(maxsize=None)
def load_state_county_zip_data():
    states_file = "data/us_states_reduced.parquet"
    counties_file = "data/us_counties_reduced.parquet"
    zipcodes_file = "data/us_zipcodes_reduced.parquet"

    states = gpd.read_parquet(states_file)
    counties = gpd.read_parquet(counties_file)
    zipcodes = gpd.read_parquet(zipcodes_file)

    for gdf in [states, counties, zipcodes]:
        if not gdf.crs.is_geographic:
            gdf.to_crs(epsg=4326, inplace=True)

    return states, counties, zipcodes

@lru_cache(maxsize=1000)
def get_zipcode_boundary(zip_code):
    _, _, zipcodes = load_state_county_zip_data()
    column_name = 'ZCTA5CE10'
    return zipcodes[zipcodes[column_name] == str(zip_code)]

def load_geographic_data():
    states, counties, _ = load_state_county_zip_data()

    state_names = ["Select a State"] + sorted(states['NAME'].unique())
    selected_state = st.sidebar.selectbox("Select State", state_names)

    if selected_state != "Select a State":
        filtered_counties = counties[counties['STATE_NAME'] == selected_state]
        county_names = ["Select a County"] + sorted(filtered_counties['NAME'].unique())
    else:
        county_names = ["Select a County"]

    selected_county = st.sidebar.selectbox("Select County", county_names)

    zip_code = st.sidebar.text_input("Enter ZIP Code to Zoom In", placeholder="e.g., 10044")
    zipcode_boundary = get_zipcode_boundary(zip_code) if zip_code else None

    return states, counties, selected_state, selected_county, zipcode_boundary

def generate_column_mapping(columns, prefix='weighted_', replacement='weighted ', title_case=True):
    if title_case:
        return {col: col.replace(prefix, replacement).replace('_', ' ').title() for col in columns if col.startswith(prefix)}
    else:
        return {col: col.replace(prefix, replacement).replace('_', ' ') for col in columns if col.startswith(prefix)}

def move_column_to_front(columns, column_name):
    if column_name in columns:
        return [column_name] + [col for col in columns if col != column_name]
    return columns

@lru_cache(maxsize=None)
def load_hhi_description(file_path='data/HHI_Data_Dictionary_2024.csv'):
    return pd.read_csv(file_path)

def get_hhi_indicator_description(hhi_desc_df, indicator_name):
    try:
        return hhi_desc_df.loc[hhi_desc_df['weighted_2024_VARIABLE_NAME'] == indicator_name, '2024_DESCRIPTION'].values[0]
    except IndexError:
        return "No description available for this indicator."

def get_heat_risk_levels_description():
    return """
    **Heat Risk Levels:**
    
    - **0:** Little to no risk from expected heat.
    - **1:** Minor - This level of heat affects primarily those individuals extremely sensitive to heat, especially when outdoors without effective cooling and/or adequate hydration.
    - **2:** Moderate - This level of heat affects most individuals sensitive to heat, especially those without effective cooling and/or adequate hydration. Impacts possible in some health systems and in heat-sensitive industries.
    - **3:** Major - This level of heat affects anyone without effective cooling and/or adequate hydration. Impacts likely in some health systems, heat-sensitive industries, and infrastructure.
    - **4:** Extreme - This level of rare and/or long-duration extreme heat with little to no overnight relief affects anyone without effective cooling and/or adequate hydration. Impacts likely in most health systems, heat-sensitive industries, and infrastructure.
    """

@lru_cache(maxsize=None)
def project_single_geometry(geom, from_crs, to_crs):
    return gpd.GeoSeries([geom], crs=from_crs).to_crs(to_crs)[0]

def project_geometries(geometries, from_crs, to_crs):
    if isinstance(geometries, (list, tuple)):
        return [project_single_geometry(geom, from_crs, to_crs) for geom in geometries]
    else:
        return project_single_geometry(geometries, from_crs, to_crs)

def create_map(layer1_with_weighted_values, selected_hhi_indicator, heat_threshold, heat_health_index_threshold, selected_state, selected_county, states, counties, zipcode_boundary=None):
    if layer1_with_weighted_values.empty:
        st.warning("The data is empty. Please check your inputs.")
        return None

    percentile_threshold = np.percentile(layer1_with_weighted_values[selected_hhi_indicator], heat_health_index_threshold)

    # Filter out data below the threshold
    highlighted_areas = layer1_with_weighted_values[
        (layer1_with_weighted_values[selected_hhi_indicator] >= percentile_threshold) & 
        (layer1_with_weighted_values['raster_value'].isin(heat_threshold))
    ].copy()

    # Simplify geometries to reduce data size
    highlighted_areas['geometry'] = highlighted_areas['geometry'].simplify(tolerance=0.01)
    
    # Convert to EPSG:4326 for Mapbox GL
    highlighted_areas = highlighted_areas.to_crs(epsg=4326)
    
    # Prepare data for PyDeck
    highlighted_areas['fill_color'] = [[255, 0, 0, 180] for _ in range(len(highlighted_areas))]  # Corrected line

    # Create a more efficient layer
    highlight_layer = pdk.Layer(
        "GeoJsonLayer",
        highlighted_areas,
        opacity=0.8,
        stroked=False,
        filled=True,
        extruded=False,
        get_fill_color="fill_color",
        get_line_color=[0, 0, 0],
        pickable=True,
        auto_highlight=True,
        highlight_color=[255, 255, 0, 100],
    )

    layers = [highlight_layer]

    # Add simplified state and county boundaries if selected
    if selected_state != "Select a State":
        state_boundary = states[states['NAME'] == selected_state].copy()
        state_boundary['geometry'] = state_boundary['geometry'].simplify(tolerance=0.01)
        state_layer = pdk.Layer(
            "GeoJsonLayer",
            state_boundary.to_crs(epsg=4326),
            opacity=0.2,
            stroked=True,
            filled=False,
            line_width_min_pixels=2,
            get_line_color=[0, 255, 0],
        )
        layers.append(state_layer)

        if selected_county != "Select a County":
            county_boundary = counties[(counties['STATE_NAME'] == selected_state) & (counties['NAME'] == selected_county)].copy()
            county_boundary['geometry'] = county_boundary['geometry'].simplify(tolerance=0.01)
            county_layer = pdk.Layer(
                "GeoJsonLayer",
                county_boundary.to_crs(epsg=4326),
                opacity=0.5,
                stroked=True,
                filled=False,
                line_width_min_pixels=2,
                get_line_color=[255, 255, 0],
            )
            layers.append(county_layer)

    # Set initial view state
    if not highlighted_areas.empty:
        initial_view_state = pdk.ViewState(
            latitude=highlighted_areas.geometry.centroid.y.mean(),
            longitude=highlighted_areas.geometry.centroid.x.mean(),
            zoom=4,
            pitch=0,
        )
    else:
        # Fallback to a default view if no areas are highlighted
        initial_view_state = pdk.ViewState(
            latitude=39.8283,  # Approximate center of the US
            longitude=-98.5795,
            zoom=3,
            pitch=0,
        )

    # Create the PyDeck map with optimized settings
    r = pdk.Deck(
        layers=layers,
        initial_view_state=initial_view_state,
        map_style="mapbox://styles/mapbox/light-v9",
        tooltip={"text": "{" + selected_hhi_indicator + "}\nHeat Risk Level: {raster_value}"},
        views=[pdk.View(type="MapView", controller=True)],
    )

    return r

def create_plot(data, y_column, x_column, color_column, title, y_label, x_label, height=300, width=600):
    fig = px.bar(data, 
                 y=y_column, 
                 x=x_column, 
                 color=color_column,
                 labels={y_column: y_label, x_column: x_label},
                 title=title,
                 orientation='h',
                 height=height,
                 width=width)
    fig.update_layout(barmode='stack')
    return fig
